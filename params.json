{
  "name": "Ludema",
  "tagline": "An easy-to-use Python 3 library to help you create terminal games!",
  "body": "# What is Ludema? \r\n\r\nLudema is a library intended to help beginner and intermediate programmers create terminal games. The project was started specifically with beginners in mind: if you have finished the Codecademy Python course, you know enough about Python and programming to use this library. \r\n\r\nIf you want to see how a game made with Ludema looks, here is [a simple level of the classic Sokoban](https://media.giphy.com/media/3oz8xrYwZat2sw0Tni/source.gif). [The source code for this program](https://github.com/joaquinlpereyra/ludema/blob/master/sokoban.py) is less than a 100 lines of code long after stripping comments! \r\n\r\n# Why should I use Ludema?\r\n\r\nLudema rides you of the most common complications when programming a game and leaves you to code only the fun parts. You get to decide the storyline, characters, challenges, enemies, maps and levels! Ludema only helps you by providing:\r\n\r\n* A dead simple way of creating maps.\r\n* Predefined but easily customizable classes for your Player, NPCs, Items and other Pieces.\r\n* Easy interfaces to make pieces move and attack. Creating your own is easy too! \r\n* Turns are automagically implemented to make enemies and other entities respond to the player.\r\n* A provided Screen class that is in charge of printing your game to the screen. \r\n* Clear exceptions that make it obvious where the problem was.\r\n* Emphasis on documentation: a method isn't a method until it has a clear and complete docstring. \r\n\r\n# I won't believe it till I see it\r\n\r\nOK. Believe it:\r\n```python\r\nimport ludema\r\n\r\n# create a main character\r\nguy = ludema.pieces.Player(Fore.GREEN + \"\\u03A8\", \"Guy\")\r\n\r\n# a function that gives us wall objects\r\ndef new_wall():\r\n    return ludema.pieces.Wall(letter = \".\")\r\n\r\n# time to create a blueprint for our first board\r\nblueprint = \"\"\"\r\n. . . . . . . . \r\n. . * * * * * .\r\n. . * . . @ * .\r\n* * * . . . * .\r\n* . . . . . * . \r\n* * * * * * *\r\n\"\"\" \r\n\r\n# now we define a legend for our map blueprint\r\nlegend = {'*': new_wall,\r\n          '@': guy}\r\n\r\n# we define when the board is won and when is lost\r\n# we will win whenever we move our guy once.\r\nwin_conditions = [lambda: len(guy.movements.history) == 1]\r\n# and we will never lose\r\nlose_contidition = [lambda: False]\r\n\r\n# and now we can create our map\r\n# everything that is not on the legend will be interpreted as empty space on the board\r\nboard = Board.new_from_blueprint(\"First\", level1, leyend, win_conditions, lose_conditions)\r\n\r\n# lets define a simple function to control our guy over the keyboard\r\n# with WASD keys, like FPS games do\r\ndef control_guy():\r\n    mappings = {\"w\": guy.move.up,\r\n                \"s\": guy.move.down,\r\n                \"d\": guy.move.right,\r\n                \"a\": guy.move.left,\r\n                \"q\": sys.exit}\r\n\r\n    action = user_input()\r\n    try:\r\n        mappings[action]()\r\n    except KeyError:\r\n        print(\"That's not an action. Try again\")\r\n\r\n# that's it, we can start our game:\r\nscreen = Screen(lambda: print(board), control_guy)\r\nwhile True:\r\n    screen.show(clear_after=True)\r\n    if board.lost or board.won:\r\n        break\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}