

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ludema.board &mdash; Ludema 1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Ludema 1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Ludema
          

          
          </a>

          
            
            
              <div class="version">
                0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <!-- Local TOC -->
                <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Ludema</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>ludema.board</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ludema.board</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">ludema</span> <span class="k">import</span> <span class="n">pieces</span>
<span class="kn">from</span> <span class="nn">ludema</span> <span class="k">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">ludema.abstract.utils</span> <span class="k">import</span> <span class="n">Position</span><span class="p">,</span> <span class="n">Direction</span>
<span class="kn">from</span> <span class="nn">ludema.abstract.piece</span> <span class="k">import</span> <span class="n">Piece</span>
<span class="kn">from</span> <span class="nn">ludema.exceptions</span> <span class="k">import</span> <span class="p">(</span><span class="n">PieceIsNotOnThisBoardError</span><span class="p">,</span> <span class="n">OutOfBoardError</span><span class="p">,</span>
                               <span class="n">PositionOccupiedError</span><span class="p">,</span> <span class="n">TurnCanOnlyBeIncreased</span><span class="p">,</span>
                               <span class="n">TurnsAreOver</span><span class="p">,</span> <span class="n">WrongSizeOnX</span><span class="p">,</span> <span class="n">WrongSizeOnY</span><span class="p">,</span>
                               <span class="n">RowsOfDifferentSizes</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The purpose of this module is to define a board where the pieces can move.</span>
<span class="sd">The majority of this work is carried of by the Board class, but the</span>
<span class="sd">Tile is also quite important.</span>
<span class="sd">&quot;&quot;&quot;</span>




<div class="viewcode-block" id="Board"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board">[docs]</a><span class="k">class</span> <span class="nc">Board</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Defines a simple rectangular map where the Pieces interact.  &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Board.new_from_blueprint"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.new_from_blueprint">[docs]</a>    <span class="k">def</span> <span class="nf">new_from_blueprint</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">blueprint</span><span class="p">,</span> <span class="n">legend</span><span class="p">,</span> <span class="n">win_conditions</span><span class="p">,</span>
                           <span class="n">lose_conditions</span><span class="p">,</span> <span class="n">empty_repr</span> <span class="o">=</span> <span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="n">turn_limit</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An alternative creator for Board, which uses Board.fill_board_with_blueprint</span>
<span class="sd">        inmediatly after creation to create a board according to a blueprint</span>
<span class="sd">        and a legend. Refer to documentation for that method for more information.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): the name of the board</span>
<span class="sd">            blueprint (str): the blueprint for the board</span>
<span class="sd">            legend ({key: (Piece | [Piece] | (nullary function -&gt; Piece}): legend</span>
<span class="sd">                for the blueprint</span>
<span class="sd">            win_conditions ([nullary functions]): each turn will be evaluated, if</span>
<span class="sd">                ONE returns True, the board is WON</span>
<span class="sd">            lose_condtitions ([nullary functions]): idem win_conditions, but if ONE</span>
<span class="sd">                returns True, the board is considered lost</span>
<span class="sd">            empty_repr (str): what should an empty espace be represented as?</span>
<span class="sd">            turn_limit: (int): if turn limit is passed, raise TurnsAreOver error.</span>
<span class="sd">                any negative number will be interpreted as no turn limit.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">blueprint</span> <span class="o">=</span> <span class="n">blueprint</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">blueprint</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">board</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">),</span> <span class="n">win_conditions</span><span class="p">,</span> <span class="n">lose_conditions</span><span class="p">,</span> <span class="n">empty_repr</span><span class="p">,</span> <span class="n">turn_limit</span><span class="p">)</span>
        <span class="n">board</span><span class="o">.</span><span class="n">fill_board_with_blueprint</span><span class="p">(</span><span class="n">blueprint</span><span class="p">,</span> <span class="n">legend</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">board</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">,</span> <span class="n">win_conditions</span><span class="p">,</span> <span class="n">lose_conditions</span><span class="p">,</span>
                 <span class="n">empty_repr</span><span class="o">=</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="n">turn_limit</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            name (str): the name of the board</span>
<span class="sd">            size_x (int): the horizontal size of the board</span>
<span class="sd">            size_y (int): the vertical size of the board</span>
<span class="sd">            win_conditions ([nullary functions]): each turn will be evaluated, if</span>
<span class="sd">                ONE returns True, the board is WON</span>
<span class="sd">            lose_condtitions ([nullary functions]): idem win_conditions, but if ONE</span>
<span class="sd">                returns True, the board is considered lost</span>
<span class="sd">            empty_repr (str): what should an empty espace be represented as?.</span>
<span class="sd">            turn_limit: (int): if turn limit is passed, raise TurnsAreOver error.</span>
<span class="sd">                any negative number will be interpreted as no turn limit.</span>

<span class="sd">        See also:</span>
<span class="sd">            :func:`~ludema.board.Board.new_from_blueprint`: alternative contructor for a Board.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">win_conditions</span> <span class="o">=</span> <span class="n">win_conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lose_conditions</span> <span class="o">=</span> <span class="n">lose_conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_x</span> <span class="o">=</span> <span class="n">size_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_y</span> <span class="o">=</span> <span class="n">size_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">empty_repr</span> <span class="o">=</span> <span class="n">empty_repr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__create_board</span><span class="p">(</span><span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">players</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npcs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># non playable characters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">turn_limit</span> <span class="o">=</span> <span class="n">turn_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_turn</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">won</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property will return wether the board has been won or not.</span>
<span class="sd">        Has no setter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">win_condition</span><span class="p">()</span> <span class="k">for</span> <span class="n">win_condition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_conditions</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property will return wether the board has been lost or not.</span>
<span class="sd">        Has no setter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">lose_condition</span><span class="p">()</span> <span class="k">for</span> <span class="n">lose_condition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lose_conditions</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">turn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This property defines the turns passed on the board.</span>
<span class="sd">        You can increment it as you wish, but you can never decrement it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_turn</span>

    <span class="nd">@turn</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">turn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_turn</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_turn</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">turn</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TurnCanOnlyBeIncreased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">turn</span><span class="p">,</span> <span class="n">new_turn</span><span class="p">)</span>
        <span class="n">turns_passed</span> <span class="o">=</span> <span class="n">new_turn</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_turn</span>  <span class="c1"># in most cases this should be 1</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">turns_passed</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">character</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npcs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">):</span>
                <span class="n">character</span><span class="o">.</span><span class="n">do_passive_action</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_turn</span> <span class="o">=</span> <span class="n">new_turn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">turn_limit</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_turn</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">turn_limit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TurnsAreOver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__create_board</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill board with empty tiles.</span>

<span class="sd">        Args:</span>
<span class="sd">            size_x: width of board</span>
<span class="sd">            size_y: height of board</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">board</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size_x</span><span class="p">):</span>
            <span class="n">board</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size_y</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">board</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;How the board will represented as a string.&quot;&quot;&quot;</span>

        <span class="c1"># NOTE: this is quite the mess so don&#39; touch unless you know</span>
        <span class="c1"># what you&#39;re doing</span>

        <span class="k">def</span> <span class="nf">board_from_column_to_rows</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Our board is a list of COLUMNS. Return a list of ROWS.&quot;&quot;&quot;</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># range is reversed so as to start printing from the topmost row</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_y</span><span class="p">)):</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_x</span><span class="p">)]</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rows</span>

        <span class="n">map_</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">board_from_column_to_rows</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                <span class="n">name_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tile</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">tile</span><span class="p">):</span>
                    <span class="n">map_</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_repr</span>
                <span class="k">elif</span> <span class="n">name_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">map_</span> <span class="o">+=</span>  <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tile</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">name_length</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">map_</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tile</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">name_length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">map_</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tile</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">map_</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tile</span><span class="p">))</span>

            <span class="n">map_</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">map_</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the graphical representation of the map</span>
<span class="sd">        plus the classical python representation of an object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span> <span class="o">+</span>
                <span class="s1">&#39; Board Name: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;|&#39;</span> <span class="o">+</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__repr__</span><span class="p">())</span>

<div class="viewcode-block" id="Board.fill_board_with_blueprint"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.fill_board_with_blueprint">[docs]</a>    <span class="k">def</span> <span class="nf">fill_board_with_blueprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blueprint</span><span class="p">,</span> <span class="n">legend</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take a blueprint and a legend for it and fill the board</span>
<span class="sd">        according to them.</span>

<span class="sd">        The blueprint string ignores blank spaces and automatically ignores</span>
<span class="sd">        the first and last lines of the string. That is to allow for this</span>
<span class="sd">        very convenient format: ::</span>

<span class="sd">            blueprint = \&quot;\&quot;\&quot;</span>
<span class="sd">            . . . . . .</span>
<span class="sd">            . * * * * .</span>
<span class="sd">            . * @ . * .</span>
<span class="sd">            . * * * * .</span>
<span class="sd">            . . . . . .</span>
<span class="sd">            \&quot;\&quot;\&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            blueprint (str): a string representing the board, example given above</span>
<span class="sd">            legend ({letter: (Piece | [Piece] | nullary function -&gt; Piece): a dictionary</span>
<span class="sd">                that maps from characters found on the blueprint to which piece</span>
<span class="sd">                should be put in the place specified by the blueprint.</span>
<span class="sd">                if legend[letter] is a list, the last element of the list will be</span>
<span class="sd">                put first (scanning from the top lefmost corner and continuing</span>
<span class="sd">                to the right and then belown).</span>
<span class="sd">                if legend[letter] is a nularry function that returns a Piece,</span>
<span class="sd">                the piece returned by the nulary function will be put in place</span>

<span class="sd">        Raises:</span>
<span class="sd">            WrongeSizeOnX: if the blueprint doesn&#39;t have the correct width</span>
<span class="sd">            WrongSizeOnY: if the blueprint doesn&#39;t have correct height</span>
<span class="sd">            RowsOfDifferentSizes: if the blueprint isn&#39;t rectangular</span>
<span class="sd">            ImpossibleToExtractPiece: if something weird happened when</span>
<span class="sd">                trying to excract a Piece from the legend</span>

<span class="sd">        Example:</span>

<span class="sd">            Defining a blueprint and a legend is simple. The following should</span>
<span class="sd">            be clear enough.::</span>

<span class="sd">                blueprint = \&quot;\&quot;\&quot;</span>
<span class="sd">                . . . . . .</span>
<span class="sd">                . * * * * .</span>
<span class="sd">                . * @ . * .</span>
<span class="sd">                . * * * * .</span>
<span class="sd">                . . . . . .</span>
<span class="sd">                \&quot;\&quot;\&quot;</span>
<span class="sd">                lengend = {&#39;*&#39;: Wall,</span>
<span class="sd">                           &#39;@&#39;: myCharacter}</span>
<span class="sd">                my_board.fill_board_with_blueprint(blueprint, legend)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># NOTE: this creates a copy of the lists in the dict, because</span>
        <span class="c1"># extract_pieces_from_possible_containers modfies a potential list</span>
        <span class="c1"># this dictionary holds as a value, leading to some very unfortunate</span>
        <span class="c1"># and hard to trace bugs</span>
        <span class="n">legend</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">copy_lists_in_dictionary</span><span class="p">(</span><span class="n">legend</span><span class="p">)</span>

        <span class="n">blueprint</span> <span class="o">=</span> <span class="n">blueprint</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">blueprint</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_y</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongSizeOnY</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_x</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongSizeOnX</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">RowsOfDifferentSizes</span>

        <span class="k">for</span> <span class="n">y_position</span><span class="p">,</span> <span class="n">string</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">lines</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">x_position</span><span class="p">,</span> <span class="n">letter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">legend</span><span class="p">:</span>
                    <span class="n">piece</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">extract_pieces_from_possible_containers</span><span class="p">(</span><span class="n">legend</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">put_piece</span><span class="p">(</span><span class="n">piece</span><span class="p">,</span> <span class="n">x_position</span><span class="p">,</span> <span class="n">y_position</span><span class="p">)</span></div>

<div class="viewcode-block" id="Board.put_piece"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.put_piece">[docs]</a>    <span class="k">def</span> <span class="nf">put_piece</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piece</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Puts a piece on the board.</span>

<span class="sd">        Args:</span>
<span class="sd">            piece (Piece): the piece which shall be put into the board</span>
<span class="sd">            x (int): The x coordinate where to put the piece.</span>
<span class="sd">            y (int): the y coordinate where to put the piece.</span>

<span class="sd">        Raises:</span>
<span class="sd">            OutOfBoardError: if (x,y) coordinates are not on board</span>
<span class="sd">            PositionOccupiedError: if position on (x,y) is already occupied and</span>
<span class="sd">                that tile is not walkable</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">position</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__try_moving_there</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">OutOfBoardError</span><span class="p">,</span> <span class="n">PositionOccupiedError</span><span class="p">):</span>
            <span class="k">raise</span>

        <span class="c1"># NOTE: This is THE ONLY PLACE where we create the bidirectional, 1 to 1</span>
        <span class="c1"># relationship between a tile and a piece.</span>
        <span class="n">destinity_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
        <span class="n">destinity_tile</span><span class="o">.</span><span class="n">piece</span> <span class="o">=</span> <span class="n">piece</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">piece</span><span class="p">,</span> <span class="n">pieces</span><span class="o">.</span><span class="n">NPC</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">npcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">piece</span><span class="p">,</span> <span class="n">pieces</span><span class="o">.</span><span class="n">Player</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span></div>

<div class="viewcode-block" id="Board.put_piece_on_column"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.put_piece_on_column">[docs]</a>    <span class="k">def</span> <span class="nf">put_piece_on_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piece_constructor</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Puts pieces returned by piece_constructor on the column</span>
<span class="sd">        of position X.</span>

<span class="sd">        If no ranges are specified, the whole row will be filled.</span>

<span class="sd">        Args:</span>
<span class="sd">            piece_constructor (nullary function): a function that returns the piece</span>
<span class="sd">            x (int): the x position of the column</span>
<span class="sd">            ranges (*tuples): arbitrary amout of ranges to put the piece on the column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_y</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">put_piece</span><span class="p">(</span><span class="n">piece_constructor</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Board.put_piece_on_row"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.put_piece_on_row">[docs]</a>    <span class="k">def</span> <span class="nf">put_piece_on_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piece_constructor</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ranges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Puts pieces returned by piece_constructor on the row of position Y.</span>

<span class="sd">        If no ranges are specified, the whole row will be filled.</span>

<span class="sd">        Args:</span>
<span class="sd">            piece_constructor (nullary function): a function that returns the piece</span>
<span class="sd">            y (int): the y position of the column</span>
<span class="sd">            ranges (*tuples): arbitrary amout of ranges to put the piece on the row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_y</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">put_piece</span><span class="p">(</span><span class="n">piece_constructor</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Board.remove_piece"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.remove_piece">[docs]</a>    <span class="k">def</span> <span class="nf">remove_piece</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piece</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes an object from the map given its position.</span>
<span class="sd">        Returns the (x,y) coordinates where the piece was located.</span>

<span class="sd">        Args:</span>
<span class="sd">            piece (Piece): the piece which will be removed</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int, int): the cordinates from where the piece was removed</span>

<span class="sd">        Raises:</span>
<span class="sd">            PieceIsNotOnThisBoardError: if the piece.home_board is not this one</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">piece</span><span class="o">.</span><span class="n">home_board</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PieceIsNotOnThisBoardError</span><span class="p">(</span><span class="n">piece</span><span class="o">=</span><span class="n">piece</span><span class="p">,</span> <span class="n">board</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">put_piece</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">piece</span><span class="o">.</span><span class="n">position_x</span><span class="p">,</span> <span class="n">piece</span><span class="o">.</span><span class="n">position_y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">piece</span><span class="o">.</span><span class="n">position_x</span><span class="p">,</span> <span class="n">piece</span><span class="o">.</span><span class="n">position_y</span></div>

<div class="viewcode-block" id="Board.get_adjacent_to_tile"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.get_adjacent_to_tile">[docs]</a>    <span class="k">def</span> <span class="nf">get_adjacent_to_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of the form {DIRECTION: TILE or None}.</span>
<span class="sd">        None will be the value only if the direction is outside of the map for</span>
<span class="sd">        the requested center tile.</span>

<span class="sd">        Args:</span>
<span class="sd">            tile (Tile): the &#39;center&#39; tile, which surroundings we&#39;re looking for</span>

<span class="sd">        Returns:</span>
<span class="sd">            {Direction: Tile | None}: surroundings of the tile given as parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">position</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">position</span>
        <span class="n">ideal_adjacent</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Direction</span><span class="o">.</span><span class="n">UP</span><span class="p">:</span> <span class="n">Position</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">Direction</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">:</span> <span class="n">Position</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
            <span class="n">Direction</span><span class="o">.</span><span class="n">DOWN</span><span class="p">:</span> <span class="n">Position</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">Direction</span><span class="o">.</span><span class="n">LEFT</span><span class="p">:</span> <span class="n">Position</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>  <span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="n">adjacent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">ideal_adjacent</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_position</span><span class="p">(</span><span class="n">position</span><span class="p">):</span>
                <span class="n">adjacent</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adjacent</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">adjacent</span></div>

<div class="viewcode-block" id="Board.column_on_position"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.column_on_position">[docs]</a>    <span class="k">def</span> <span class="nf">column_on_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yields the tiles on column in position x.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (int): the column which tiles we want to get</span>

<span class="sd">        Yields:</span>
<span class="sd">            The tiles on column x.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_y</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span></div>

<div class="viewcode-block" id="Board.row_on_postition"><a class="viewcode-back" href="../../ludema.html#ludema.board.Board.row_on_postition">[docs]</a>    <span class="k">def</span> <span class="nf">row_on_postition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yields the tiles on row in position y.</span>

<span class="sd">        Args:</span>
<span class="sd">            y (int): the row which tiles we want to get</span>

<span class="sd">        Yields:</span>
<span class="sd">            The tiles on row y.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_is_valid_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            position (Position): the position which we are interested in</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if position inside the map, False if not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__check_position_inside_map</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="n">valid_position</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">OutOfBoardError</span><span class="p">:</span>
            <span class="n">valid_position</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">valid_position</span>

    <span class="k">def</span> <span class="nf">__try_moving_there</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raises either a OutOfBoardError or a PositionOccupiedError</span>
<span class="sd">        if the position given is out of the board or occupied.</span>

<span class="sd">        Args:</span>
<span class="sd">            position (Position): the position which we are insterested in</span>

<span class="sd">        Raises:</span>
<span class="sd">            OutOfBoardError: if the position is outside of this board</span>
<span class="sd">            PositionOccupiedError: if the posision is already occupied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__check_position_inside_map</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">__check_position_occupied</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">condition</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">OutOfBoardError</span><span class="p">,</span> <span class="n">PositionOccupiedError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">__check_position_inside_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if a given position is found within the limits</span>
<span class="sd">        of the board.</span>

<span class="sd">        Args:</span>
<span class="sd">            position (Position): the position to check</span>

<span class="sd">        Raises:</span>
<span class="sd">            OutOfBoardError: if posisition is out of this board</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_y</span> <span class="o">&lt;=</span> <span class="n">y_pos</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_x</span> <span class="o">&lt;=</span> <span class="n">x_pos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OutOfBoardError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__check_position_occupied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if a given position if already occupied by other</span>
<span class="sd">        object.</span>

<span class="sd">        Args:</span>
<span class="sd">            position (Position): the position to check</span>

<span class="sd">        Raises:</span>
<span class="sd">            PositionOccupiedError: if posisition is already occupied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="p">[</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">piece</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tile</span><span class="o">.</span><span class="n">piece</span><span class="o">.</span><span class="n">walkable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PositionOccupiedError</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tile"><a class="viewcode-back" href="../../ludema.html#ludema.board.Tile">[docs]</a><span class="k">class</span> <span class="nc">Tile</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A tile is the atomic unit of the Board.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">piece</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Every tile lives on a board and has a position there.</span>
<span class="sd">        A tile may or may not hold a piece.</span>

<span class="sd">        Args:</span>
<span class="sd">            board (Board): the board where the tile lives.</span>
<span class="sd">            position (Position): the position of this tile.</span>
<span class="sd">            piece (Piece or None): the piece present on this tile.</span>

<span class="sd">        Note:</span>
<span class="sd">            You most probably don&#39;t want to create a Tile. Boards manage and</span>
<span class="sd">            create tiles by themselves when they are created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">board</span> <span class="o">=</span> <span class="n">board</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_piece_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">piece</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">piece</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The piece property returns the topmost piece on a tile (as tiles</span>
<span class="sd">        may hold several pieces).</span>

<span class="sd">        Setting the tile&#39;s piece to None will **remove** and</span>
<span class="sd">        return the topmost piece.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_piece_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@piece</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">piece</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piece</span><span class="p">):</span>
        <span class="c1"># if we currently have no piece or it is walkable, just change the topmost</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">piece</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">piece</span><span class="o">.</span><span class="n">walkable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_piece_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
            <span class="n">piece</span><span class="o">.</span><span class="n">home_tile</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># we interpret the &#39;None&#39; type as removing a piece from the tile</span>
        <span class="k">if</span> <span class="n">piece</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_piece_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">original</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span>
        <span class="n">custom</span> <span class="o">=</span> <span class="s2">&quot; at </span><span class="si">{0}</span><span class="s2"> on map </span><span class="si">{1}</span><span class="s2"> holding </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">piece</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">original</span> <span class="o">+</span> <span class="n">custom</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">piece</span><span class="o">.</span><span class="n">letter</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">piece</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Joaquin L. Pereyra.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>